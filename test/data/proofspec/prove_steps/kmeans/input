extern fn dist(a : Int * Int, b : Int * Int) -> Int {}
extern fn addPoints(a : Int * Int, b : Int * Int) -> Int * Int {}
extern fn div(a : Int * Int, b : Int) -> Int * Int {}
extern fn nearestCenter(p : Int * Int, centers : [Int * Int]) -> Int {}
fn kmeans(points : [Int * Int], centers : [Int * Int]) -> [Int * Int] {
  iter : Int = 0;
  while (iter < 10) {
    new_centers : [Int * Int] = centers;
    new_center_count : [Int] = [];
    i : Int = 0;
    while (i < length(points)) {
      min_id : Int = nearestCenter(points[i], centers);
      new_centers[min_id] := addPoints(new_centers[min_id], points[i]);
      new_center_count[min_id] := new_center_count[min_id] + 1;
      i := i + 1;
    }
    i := 0;
    while (i < length(new_centers)) {
      new_centers[i] := div(new_centers[i], new_center_count[i]);
      i := i + 1;
    }
    centers := new_centers;
    iter := iter + 1;
  }
  return centers;
}
---
extern fn dist(a : Int * Int, b : Int * Int) -> Int {}
extern fn addPoints(a : Int * Int, b : Int * Int) -> Int * Int {}
extern fn div(a : Int * Int, b : Int) -> Int * Int {}
extern fn nearestCenter(p : Int * Int, centers : [Int * Int]) -> Int {}
fn kmeans(points : [Int * Int], centers : [Int * Int]) -> [Int * Int] {
  iter : Int = 0;
  while (iter < 10) {
    local_centers : [Int * Int] = centers;
    new_centers : [Int * Int] =
      map((p : Int * ((Int * Int) * Int)) => div(fst (snd p), snd (snd p)),
          reduceByKey((p1 : (Int * Int) * Int) (p2 : (Int * Int) * Int) =>
                        (addPoints(fst p1, fst p2), snd p1 + snd p2),
                      ((0, 0), 0),
                      map((p : Int * Int) => (nearestCenter(p, local_centers), (p, 1)), points)));
    centers := new_centers;
  }
  return centers;
}